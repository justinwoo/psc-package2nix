# Psc-Package2Nix

[![Build Status](https://travis-ci.com/justinwoo/psc-package2nix.svg?branch=master)](https://travis-ci.com/justinwoo/psc-package2nix)

Tool to derive a Nix expression from a `psc-package.json` configuration.

Prefetches Git SHA of the total dependencies you depend on.

## Usage example

### `default.nix`

In the [test](./test) setup, we have the `packages.nix` that is generated by `psc-package2nix` checked in, so you can see what kind of file we are generating here.

Then when you look at `default.nix`, you will find that we have a normal derivation, where...

First, we use [easy-purescript-nix](https://github.com/justinwoo/easy-purescript-nix) to easily install the PureScript compiler and Psc-Package (see `buildInputs` below).

Then, we bring in `psc-package2nix` from this repository remotely. This expression takes an argument should you wish to override `pkgs`, but this will default to using `<nixpkgs>`.

```nix
let
  pkgs = import <nixpkgs> {};

  easy-ps = import (pkgs.fetchFromGitHub {
    owner = "justinwoo";
    repo = "easy-purescript-nix";
    rev = "347ab7c91634462c2039c6c0641af5386c251a98";
    sha256 = "0njhcl7dq58b3kmjbz6ndsccv4pcmdxc5lg7p13115phcmznpn99";
  });

  psc-package2nix = import (pkgs.fetchFromGitHub {
    owner = "justinwoo";
    repo = "psc-package2nix";
    rev = "414ba2f58e270dece3834021e380c41cd940b983";
    sha256 = "0lrw2k1gm4aamnlxi16syibyqi7i3nvx9bwzq889vd1p0sbzxs9x";
  }) {};

in pkgs.stdenv.mkDerivation {
  name = "test";
  src = ./.;

  buildInputs
    = [
      easy-ps.inputs.purs
      easy-ps.inputs.psc-package-simple
      psc-package2nix
    ];
}
```

With this, we can start up a nix-shell that runs `psc-package2nix` to generate `packages.nix` of our Psc-Package dependencies.

### `install-deps.nix`

Then we have a separate `install-deps.nix` file which uses the generated `packages.nix` file.  We bring in the packages that have been generated here and create a list using the attribute values of the set (reminder: records are called "attribute sets" in Nixlang).

The list we prepare wil be a series of copy commands for the Psc-Package dependencies to be copied from the Nix Store, which will give us local mutable copies in `.psc-package/`. Then we can complete the `buildInputs` with the derivations we need for our derivation, along with a shell hook that will copy the dependencies over.

```nix
let
  pkgs = import <nixpkgs> {};

  # import our packages
  packages = import ./packages.nix {};

  # these are the package derivations we will want to work with
  packageDrvs = builtins.attrValues packages.inputs;

  # these are the copy commands for copying our dependencies from the nix store
  # this means that if we have overlapping packages between sets or between projects,
  # they come from the same source!
  copyCmds = map (x: let target = ".psc-package/${packages.set}/${x.name}/${x.version}"; in ''
    mkdir -p ${target}
    cp --no-preserve=mode,ownership,timestamp -r ${toString x.outPath}/* ${target}
  '') packageDrvs;

in pkgs.stdenv.mkDerivation {
  name = "install-deps";
  src = ./.;

  # make sure we depend on these explicitly
  buildInputs = packageDrvs;

  # when the shell starts, we can run these commands to copy over our dependencies.
  shellHook = toString copyCmds;
}
```

Of course, you might use the full power of the Nix language to tweak this to fit your uses.

## More Information

If you need more information on how Psc-Package works, you might see the Spacchetti guide page here: <https://spacchetti.readthedocs.io/en/latest/intro.html>

## Complaints

PRs welcome

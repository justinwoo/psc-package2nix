#!/usr/bin/env perl

use warnings;
use strict;
use feature 'say';
use FindBin qw($RealBin);
use PscPackage2Nix::GetDeps;

my $dir = ".psc-package2nix";
my $config = 'psc-package.json';

my $derivation_template = <<"END";

    "DEP" = pkgs.stdenv.mkDerivation {
      name = NAME;
      version = VERSION;
      src = pkgs.fetchgit {
        url = REPO;
        rev = REV;
        sha256 = HASH;
      };
      phases = "installPhase";
      installPhase = "ln -s \$src \$out";
    };
END

my $file_template = <<END;
# This file was generated by Psc-Package2Nix
# You will not want to edit this file.
# To change the contents of this file, first fork Psc-Package2Nix
# And edit the \$file_template

{ pkgs ? import <nixpkgs> {} }:

let
  inputs = {
DERIVATIONS};

in {
  inherit inputs;

  set = SET;
  source = SOURCE;
}
END

print `mkdir -p $dir`;

chomp(my $source = `jq '.source' psc-package.json -r`);
chomp(my $set = `jq '.set' psc-package.json -r`);

my $package_set_dir = ".psc-package/$set/.set";
my $json = "$package_set_dir/packages.json";

unless (-e $json) {
    chomp(my $sha256 = `nix-prefetch-git $source --rev $set --quiet | jq '.sha256' -r`);
    if ($? != 0) {
        die "Error on downloading package set";
    }
    # magic hash for empty git repositories, because nix-prefetch-git does not fail
    if ($sha256 eq "0sjjj9z1dhilhpc8pq4154czrb79z9cm044jvn75kxcjv6v5l2m5") {
        die "Fetched an empty git repository for the package set. Verify that the package set is real."
    }

    my $package_set_expr = <<END;
        (import <nixpkgs> {}).fetchgit {
           url = "${source}";
           rev = "${set}";
           sha256 = "${sha256}";
        }
END

    print `nix-build -E '$package_set_expr' -o $package_set_dir`;

    if ($? != 0) {
        die "Error on downloading package set";
    }
}

my @deps = PscPackage2Nix::GetDeps::getDeps($config, $json);

my %targets = ();
my %versions = ();
my %repos = ();
my @pids;

# ensure I have my hashes downloaded
foreach my $depQuoted (@deps) {
  (my $dep = $depQuoted) =~ s/"//g;
  chomp(my $version = `jq '.$depQuoted.version' $json -r`);
  chomp(my $repo = `jq '.$depQuoted.repo' $json -r`);
  my $target = "$dir/$dep-$version";

  $versions{$dep} = $version;
  $targets{$dep} = $target;
  $repos{$dep} = $repo;

  unless (-e $target) {
    my $pid = fork;
    if (not defined $pid) {
        die "Couldn't fork new child processes\n";
    } elsif ($pid == 0) {
        say "fetching $target";
        print `nix-prefetch-git $repo --rev $version --quiet | jq '.sha256' -r > $target`;

        if ($? != 0) {
            die "Nix-Prefetch-Git failed at $target";
        } else {
            exit;
        }
    } else {
        push @pids, $pid;
    }
  }
}

for my $pid (@pids) {
    waitpid $pid, 0;
}

my $derivations = "";

# build up my derivations
foreach my $depQuoted (@deps) {
  (my $dep = $depQuoted) =~ s/"//g;
  my $version = $versions{$dep};
  my $target = $targets{$dep};
  my $repo = $repos{$dep};

  chomp(my $hash = `cat $target`);

  my $derivation = $derivation_template;
  $derivation =~ s/DEP/$dep/;
  $derivation =~ s/NAME/"$dep"/;
  $derivation =~ s/VERSION/"$version"/;
  $derivation =~ s/REPO/"$repo"/;
  $derivation =~ s/REV/"$version"/;
  $derivation =~ s/HASH/"$hash"/;

  $derivations .= $derivation;
}

my $file = $file_template;
$file =~ s/DERIVATIONS/$derivations/;
$file =~ s/SET/"$set"/;
$file =~ s/SOURCE/"$source"/;

my $filename = 'packages.nix';
open(my $fh, '>', $filename) or die "Could not get file handle for $filename";
print $fh $file;
close $fh;

say "wrote $filename";
